\documentclass[a4paper, 12pt]{article}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=C,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\usepackage[english]{babel}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{index}

\makeindex

\begin{document}
	\title{Tutorat microprocesseur}
	\author{Corentin GIELEN, Florian DERLIQUE, Miaoqi WANG, Maxence NEUS}
	\maketitle
	
	\newpage
	\tableofcontents
	\newpage
	
	\section{Introducion}
		Nous avons à réaliser un radar de contrôle routier.
		Le radar doit pouvoir réaliser les fonctions suivantes :
		\begin{enumerate}
			\item Mesurer la vitesse d'un véhicule qui entre dans sa zone d'action
			\item Permettre de changer la vitesse maximale authorisée à l'aide d'un clavier
			\item Nous avons aussi ajouté des afficheurs 7 segments pour afficher la vitesse alors qu'elle est tapée.
			\item Si la vitesse mesurée est supérieure à la vitesse maximale, activer le flash et envoyer la vitesse mesurée sur l'imprimante série
		\end{enumerate}
	
		On nous demande ici en plus, de ne flasher que lorsque le vehicule se trouve à une distance de moins de 30m du radar afin que l'appareil photo puisse avoir une bonne vue de la plaque d'immatriculation. Cette restriction nous as posé quelque problème que nous detailliron plus tard dans la partie sur les limites du système.
		
		
	\newpage
	\section{Architecture Matérielle}
		\subsection{Matériel}
		Nous avons à notre dispositon les éléments suivants :
		\begin{itemize}
			\item Un télémetre qui fournit un signal analogique proportionnel à la distance entre le radar et la voiture
			qui donne une valeur entre 0V pour une distance de 0m et 5v pour une distance de 100m
			\item Un détecteur de présence qui passe de l'état 0 à l'état 1 lorsqu'une voiture entre dans le champ de mesure du télémetre
			\item Un flash que l'on peut déclancher directement sur un pin digital
			\item Une imprimante série pour imprimer les vitesses mesurées
			\item Les composants standards
		\end{itemize}	
		\subsection{Mise en place de l'architecture}
		\begin{figure}[h]
		\centering
		\includegraphics[width = 9cm]{schema.jpg}
		\caption{schema de cablage}
		\end{figure}
		\newpage
		\subsubsection{Interface utilisateur}
		Pour réaliser la fonction 2, nous avons besoin de permettre à l'utilisateur de rentrer une nouvelle valeur pour la vitesse maximale authorisée. Pour ce faire, nous avons incorporer un clavier 12 touches (0-9, Valider, Annuler) et 3 afficheurs 7 segments multiplexés pour afficher la valeur entrée à l'utilisateur.\\
		Le clavier est branché sur les pins PA[0:6] avec une porte OU qui permettra par la broche PD1/INT1 de travailler par interruption pour la lecture du clavier.\\
		Pour ce qui est des afficheurs 7 segments, ils sont reliés au port B pour la valeur à afficher et multiplexé par les pins PC[0:2] qui font la conection des bases des afficheurs à la masse via des transistors et des résistances de tirage.
		\subsubsection{Appareils de mesure}
		Comme le Télémetre nous fournis une valeur analogique, nous avons choisis de le relier à la broche PF0/ADC0 pour pouvoir réaliser une conversion dessus.\\
		Nous avons choisis d'utiliser le détecteur de présence par intéruption, nous le relions donc à la broche PD0/INT0.\\
		\subsubsection{Sorties utilisateur}
		Pour le flash, nous l'avons relié à la dernière broche inutilisée du port A, PA7, nous supposons qu'un appareil photo déclanchable par un front montant est relié à la même broche pour pouvoir prendre une photo de l'automobiliste qui est en exces de vitesse.\\
		L'impimante série est reliée à l'interface USART0 (PE0/RXD0;PE1/TXD1), L'imprimante fonctionne à 1200 bauds, 8bits de message, 1 bit stop et pas de parité, son initialisation sera développée dans la section 3.\\
	\newpage
	\section{Architecture Code}
		\subsection{Initialisation}
		Le convertisseur analogique numérique (ADC) est mis en place de sorte qu'il réalise des convertions sur demande en lisant sur la broche PF0/ADC0 en envoyant une interuption à la fin de la convertion.
		\begin{lstlisting}
			//ADC (convertion ADC0, single convertion)
			ADMUX = 0b0010 0000
			ADCSRA = 0b1000 1111
			ADCSRB = 0x00
		\end{lstlisting}
		
		ADMUX:
		\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
		\hline
		REFS1 & REFS0 & ADLAR & MUX4 & MUX3 & MUX2 & MUX1 & MUX0\\
		\hline
		0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
		\hline
		\end{tabular}
		\end{center}
		\begin{itemize}
			\item[REFS[1:0]] : On prends la réference sur 5V.
			\item[ADLAR] : On choisis de ne lire que les bits de poids fort, on choisis donc d'aligner à gauche.
			\item[MUX[4:0]] : On fait la convertion sur ADC0, soit l'adresse MUX = 0 0000.
		\end{itemize}
		
		ADCSRA:
		\begin{center}
			\begin{tabular}{|c|c|c|c|c|c|c|c|}
				\hline
				ADEN & ADSC & ADATE & ADIF & ADIE & ADPS2 & ADPS1 & ADPS0\\
				\hline
				1 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\
				\hline
			\end{tabular}
		\end{center}
		\begin{itemize}
			\item[ADEN] : On active l'ADC.
			\item[ADCS; ADATE; ADIF] : Utilisés lors de l'utilisation de l'ADC donc pas utiles pour l'initialisation.
			\item[ADIE] : Interrupt Enable.
			\item[ADPS[2:0]] : Prescaler, on veut que l'ADC fonctionne entre $50\ kHz$ et $200\ kHz$, la clock de l'ATMEGA etant à $16\ Mhz$, une division par 128 nous donne une fréquence acceptable (soit ADPS[2:0] = 000)
		\end{itemize}
		
		Nous utiliserons un WatchDog pour temporiser nos mesures, celui çi est ici reglé pour envoyer des interuptions toute les 0.5s (Ce choix est discuté dans la partie limites).
		\begin{lstlisting}
			//Watchdog (interruptions toute les 0.5s)
			WDTCSR = 0x10 // enable change
			WDTCSR = 0b0101 0101
		\end{lstlisting}
		WDTCSR:
		\begin{center}
			\begin{tabular}{|c|c|c|c|c|c|c|c|}
				\hline
				WDIF & WDIE & WDP3 & WDCE & WDE & WDP2 & WDP1 & WDP0\\
				\hline
				1 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\
				\hline
			\end{tabular}
		\end{center}
		\begin{itemize}
			\item[WDIF] : Interupt Flag, en lecture uniquement.
			\item[WDE; WDIE] = 01 - Interrupt mode.
			\item[WDP[3:0]] = 0101 - Timing de 0.5s.
		\end{itemize}

		Pour envoyer les mesures à l'imprimante nous devons utiliser la liaison série de l'ATMEGA comme décrit en 2.2.3, nous avons caculé la valeur de UBRR grâce à la formule donné dans la documentation $UBRR = \dfrac{f_{osc}}{16*BAUD} - 1$ qui nous donne UBRR = 832, soit 0x340 à répartir sur les registres UBRRL0 et UBRRH0.
		\begin{lstlisting}
			//printer (envoi uniquement, pas de verification, conforme au CDCF)
			UBRR (f = 16MHz) = 832
			UBRRH0 = 0x03
			UBRRL0 = 0x40
			
			UCSR0A = 0x00
			UCSR0B = 0b0000 1000
			UCSR0C = 0b0000 0110			
		\end{lstlisting}	
	
		On règle ici les afficheurs et le clavier comme décrit en 2.2.1.
		\begin{lstlisting}
			//Clavier et afficheurs
			DDRA = 0b0001 1111
			DDRB = 0x0111 1111
			DDRC = 0b0000 0111
		\end{lstlisting}
		\newpage
		On reprends ici les différents vecteurs d'interruptions utilisés ainsi que les noms des subsoutines associées.
		\begin{lstlisting}
			//vecteurs d'interuption
			.org 0x0002
				JMP IRQ_detecteur
			.org 0x0004
				JMP IRQ_clavier
			.org 0x0018
				JMP IRQ_Watchdog
			.org 0x003A
				JMP IRQ_convertion
		\end{lstlisting}
		\subsection{Structure globale}
		Afin de réaliser les mesures de vitesses, nous n'avons à notre disposition que la position du vehicule, nous allons donc avoir besoin de mesurer la distance entre le radar et le vehicule à un intervale régulier pour pouvoir par la suite calculer la vitesse. \\
		Le processus de mesure commence lorsque le vehicule entre dans la zone de mesure du télémetre et que le détecteur de présence envoie un signal d'interruption qui amène à l'appel de la procédure d'interruption $IRQ\_detecteur$.
		
		\begin{lstlisting}
			// detection d'une voiture par le detecteur de presence  
			IRQ_Detecteur:
				si cpt_detection==0 alors saut init_watch // si le capteur est en front montant on initialise le WatchDog
				//si non on reinitialise le WatchDog 
				WDTCSR<-0b00010000
				WDTCSR<-0b00000000
				cpt_detection <- 0 
				RETI
				init_watch: 
					WDTCSR<-0b00010000
					WDTCSR<-0b01001101
					cpt_detection=1
				RETI
		\end{lstlisting}
		Cette procédure a pour but de démarrer ou d'arreter le WatchDog selon si le vehicule qui a été détecté entrait ou sortait de la zone de mesure (l'interuption est règlée pour être déclanchée sur front montant comme déscendant), cette distinction est faite grâce à une variable $cpt\_detection$ qui est mise à 1 lorsqu'un vehicule est présent dans la zone et à 0 lorsque ce n'est plus le cas.\\
		
		Par la suite, le WatchDog va maintenant déclancher des interuptions toute les 0.5s sur la procédure $IRQ\_WatchDog$ comme defini lors de l'initialisation. Voyons maintenant ce que fait cette procédure:\\
		
		\begin{lstlisting}
			//interuption du watch_dog
			// quand le watch_dog est activer on active la prise de mesure
			IRQ_WDT :
				ADCSRA<-0b11001111
				RETI
		\end{lstlisting}
		Ici tout ce que fait la procédure c'est lancer une convertion sur ADC0 afin de mesurer la distance du radar au vehicule, lorsque cette mesure sera faite, le convertisseur analogique numérique lancera une interruption qui déclanchera la procédure $IRQ\_convertion$.\\
		
		\begin{lstlisting}
			IRQ_CONVERTION:
			mesure <- ADC
			si(cpt_mesure) == 0 alors saut cpt0 // c'est a dire c'est la premiere mesure de vitesse 
			si(cpt_mesure) == 1 alors saut cpt1 // c'est la 2 eme mesure de vitesse
			
			cpt0:
			Pos1<-mesure //  alors on stocke la valeur mesure par la conversion entre 0 et 255
			cpt_mesure <- 1 
			RETI
			
			cpt1:
			pos2<-mesure
			if(Pos1-Pos2)>vitesse_limite saut distflash // si la vitesse et superieur a la limite et que la voiture est a plus de 30m du tel
			cpt_mesure <- 0
			RETI
			
			distflash:// si la vitesse est superieur on attends que la distance au radar soit inferieur a 30m
			posflash<-76// 76 en annalogique soit 255/100*30 pour avoir les 30m
			si posflash<76 alors saut port_serie 
			ADCSRA<-0b11001111
			
			port_serie:
			call flash 
			call imprime 
			RETI
		\end{lstlisting}
		Cette procédure a pour but global de prendre une première mesure de vitesse au début de la zone de mesure, et si cette mesure de vitesse est supérieure à la vitesse maximale autorisée, alors le convertisseur analogique numérique est lancé en free running mode et le radar flashera le vehicule lorsque la mesure de position sera inférieure à 30m on lance la procédure de flash et d'envoi de la vitesse mesurée à l'imprimante. Ce choix est expliqué plus en détail dans la partie 4.1.\\
		Cette vitesse est d'abord convertie en $km/h$ à partir de la mesure en $m/s$ qui est utilisée en interne et ensuite envoyée caractère par caractère à l'imprimante. 
		
		\subsection{Changement de la vitesse limite par l'utilisateur}
		La vitesse limite authorisée doit pouvoir être modifiée à tout moment par l'utilisateur à l'aide du clavier, nous afficherons également la saisie sur les 3 afficheurs durant la durée de la saisie et nous désactiverons les afficheurs lorsque la saisie a été validée. Cette saisie sera stockée dans 3 variables (une pour chaque digit) ce qui facilitera la saisie et nottament la correction.
		
		
		\section{Limites}
		\subsection{Limite de l'utilisation du WatchDog à 0.5s}
		Comme nous l'avons dit en 3.1, le choix de l'intervalle entre les mesures à 0.5s entraîne des limites pour certaines vitesses qui peuvent passer à travers la zone de flash des 30m et donc dans certains cas éviter d'être flashé en roulant à une vitesse assez précise.\\
		Cette limite peut être quantifiée sous quelques conditions:
		\begin{itemize}
			\item La première mesure est faite à exactement 100m du radar.
			\item Chaque mesure qui suit est faite à exactement 0.5s d'intervalle.
			\item Chaque calcul de vitesse se fait sur deux mesures, desquelles la seconde doit se retrouver dans la zone des 30m pour être flashé
		\end{itemize}
		Dans ces conditions, un rapide script (en annexe) nous permet de déterminer les plages de vitesses qui ne pourrait pas être mesurées avec ce système, on obtient les plages suivantes :
		\begin{itemize}
			\item $[33.4;35]\ m/s$ soit $[120;126]\ km/h$
			\item $[50;69.9]\ m/s$ soit $[180;251]\ km/h$
			\item $[100.2;+\infty[\ m/s$ soit $[360.7;+\infty[\ km/h$
		\end{itemize}
		Comme on peut le constater, ces plages sont problématiques car parfaitement atteignable par un vehicule sur une autoroute (particulièrement les 2 premières). Notre solution pour palier à ce problème est celle implémentée en 3.2, l'attente en free running mode que le vehicule puisse être falshé fait que la seule façon d'éviter le radar serait de traverser la zone des 30m en moins de temps qu'il n'en faut à l'ATMEGA pour réaliser une convertion, ce qui fait que la vitesse minimale pour y parvenir devient bien trop élevée pour qu'un vehicule terrestre puisse l'atteindre.
	
		\subsection{Approximation numérique}
		Par soucis de précision 
		
\end{document}